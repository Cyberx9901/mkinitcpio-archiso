# args: source, mountpoint
_mnt_bind()
{
    msg "::: Binding ${1} to ${2}"
    mkdir -p /real_root${2}
    /bin/mount -o bind ${1} /real_root${2}
}

# args: /path/to/image_file
_mnt_squashfs()
{
    /bin/modprobe -q loop >/dev/null 2>&1
    
    img="${1}"
    base_img="${img##*/}";
    mnt="${2}"

    if [ "${copytoram}" = "y" ]; then
        msg ":: Copying squashfs image to RAM"
        /bin/cat ${img} > "/tmpfs/${base_img}"
        img="/tmpfs/${base_img}"
    fi

    msg "::: Adding new union branch: ${base_img%.*}"
    mkdir -p "/tmpfs/mnt/loop${LOOP_NUM}"
    # sometimes it takes udev a while to create device nodes
    while [ ! -e "/dev/loop${LOOP_NUM}" ]; do
        sleep 1
    done
    if ! /bin/losetup "/dev/loop${LOOP_NUM}" ${img}; then
        echo "ERROR: Cannot mount loop device /dev/loop${LOOP_NUM}"
        break
    fi
    /bin/mount -r -t squashfs "/dev/loop${LOOP_NUM}" "/tmpfs/mnt/loop${LOOP_NUM}"
    if [ "${mnt}" = "/" ]; then
        /bin/mount -t unionfs -o remount,add=:/tmpfs/mnt/loop${LOOP_NUM}=ro none "/real_root"
    else
        _mnt_bind "/tmpfs/mnt/loop${LOOP_NUM}" "${mnt}"
    fi
    export LOOP_NUM=$(( $LOOP_NUM + 1 ))
}

run_hook ()
{
    if [ "x${arch}" = "x" ]; then
        arch="$(uname -m)"
    fi

    if [ "x${ramdisk_size}" = "x" ]; then
        ramdisk_size="75%"
    fi
    msg -n ":: Mounting tmpfs, size=${ramdisk_size}..."
	mount -t tmpfs -o "size=${ramdisk_size}" tmpfs /tmpfs
    msg "done."

    # external drives may need to settle
    msg ":: Waiting for devices to settle..."
    /sbin/udevadm trigger --subsystem-match=usb
    /sbin/udevadm settle
    usbdelay=$(( ${usbdelay:-0} + 1 ))
    msg ":: Waiting ${usbdelay}s for USB devices"
    /bin/sleep "${usbdelay}"

    msg ":: Scanning for boot device..."

    /bin/mkdir -p /bootmnt
    found=0

    /bin/modprobe -q isofs >/dev/null 2>&1
    msg ":: Scanning cd drives..."
    for cdrom in /dev/hd[a-z] /dev/sr[0-9]* /dev/scd[a-z] /dev/sg[0-9]*; do
        [ ! -e "${cdrom}" ] && continue
        if mount -r -t iso9660 "${cdrom}" /bootmnt >/dev/null 2>&1; then
            if [ -e "/bootmnt/isomounts" ]; then
                found=1
                msg "${cdrom}"
                break
            fi
        else
            echo "Failed to mount ${cdrom}"
        fi
        [ ${found} -eq 0 ] && umount /bootmnt >/dev/null 2>&1
    done

    if [ ${found} -eq 0 ]; then
        msg ":: Scanning usb drives..."
        for usb in /dev/sd[a-z][0-9]; do
            [ ! -e "${usb}" ] && continue
            if mount -r -t vfat "${usb}" /bootmnt >/dev/null 2>&1 ||\
                mount -r -t ext2 "${usb}" /bootmnt >/dev/null 2>&1; then
                if [ -e "/bootmnt/isomounts" ]; then
                    found=1
                    msg "${usb}"
                    break
                fi
            else
                echo "Failed to mount ${usb}"
            fi
            [ ${found} -eq 0 ] && umount /bootmnt >/dev/null 2>&1
        done
    fi

    if [ ${found} -eq 0 ]; then
        echo "ERROR: cannot find boot device, cannot continue..."
        echo "   Falling back to interactive prompt"
        PS1="ramfs$ " /bin/sh -i
        exit 1
    fi

    /bin/modprobe -q squashfs >/dev/null 2>&1
    /bin/modprobe -q unionfs >/dev/null 2>&1

    msg ":: Mounting root (union) filesystem"
    /bin/mount -t unionfs -o dirs=/tmpfs=rw none /real_root

    export LOOP_NUM="0"
    msg ":: Mounting images"
    while read img imgarch mountpoint type; do
        # check if this line is a comment (starts with #)
        [ "${img#"#"}" != "${img}" ] && continue

        [ "$imgarch" != "$arch" ] && continue

        [ ! -f "/bootmnt/${img}" ] && continue

        if [ "${type}" = "bind" ]; then
            _mnt_bind "/bootmnt/${img}" ${mountpoint}
        elif [ "${type}" = "squashfs" ]; then
            _mnt_squashfs "/bootmnt/${img}" "${mountpoint}"
        fi
    done < "/bootmnt/isomounts"

    # Bind our bootmnt dir into the live system
    _mnt_bind /bootmnt bootmnt

    if [ -d /proc/sys/dev/cdrom ]; then
        echo 0 > /proc/sys/dev/cdrom/lock
        echo 0 > /proc/sys/dev/cdrom/autoeject
    fi

    if [ "${break}" = "y" ]; then
        echo ":: Break requested, type 'exit' to resume operation"
        echo "   NOTE: klibc contains no 'ls' binary, use 'echo *' instead"
        PS1="ramfs$ " /bin/sh -i
    fi

    udevpid=$(/bin/minips -C udevd -o pid=)
    [ "x${udevpid}" != "x" ] && /bin/kill -9 $udevpid 2>&1 >/dev/null
    #Yep, we're bailing out here.  We don't need kinit.
    msg ":: Passing control to Arch Linux Initscripts...Please Wait"
    /bin/umount /sys
    /bin/umount /proc
    exec /bin/run-init -c /dev/console /real_root /sbin/init ${CMDLINE}
}

# vim:ft=sh:ts=4:sw=4:et:
